<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_pd_integration.IncidentWorkflows</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>/*** Changes made to this script are not supported by PagerDuty ***/&#13;
PagerDuty integration methods for Incident Workflows</description>
        <name>IncidentWorkflows</name>
        <script>/*** Changes made to this script are not supported by PagerDuty ***/
var IncidentWorkflows = Class.create();
IncidentWorkflows.prototype = {
  initialize: function () {
    this.JSON = new global.JSON();
    this.logEntriesCache = {};
    this.rest = new x_pd_integration.PagerDuty_REST();
    this.snLogEntriesTable = 'x_pd_integration_workflow_log_entries';
    this.serviceNow = 'ServiceNow ITSM';
    this.webhooksV2Identified = gs.getProperty('x_pd_integration.webhooks_v2_identified') === 'true';
  },

  /* --- interface --- */

  isWorkflowEnabled: function () {
    return gs.getProperty('x_pd_integration.enable_incident_workflows') === 'true';
  },

  /**
   * Query PagerDuty to get Incident Workflow triggers for a specific incident
   * @param {String} requester a "from" field sent to PagerDuty in a header, should contain an email
   * @param {String} incidentId the id of the corresponding incident
   * @return {array} incident workflow triggers
   */
  getIncidentWorkflowTriggers: function (requester, incidentId) {
    var feature = 'incident_workflows/triggers?trigger_type=manual&amp;incident_id=' + incidentId + '&amp;limit=100';
    var response = this.rest.getAllItemsByCursor(feature, {}, requester, function (item) {
      return item.triggers;
    });

    if (response.status !== 200) {
      var responseBody = response.error ? response.error : this.extractPDIncidentError(response.body);
      gs.warn('GET Incident workflows list failed. Status: ' + response.status + '; Message: ' +
        responseBody + '; Query: ' + feature);

      throw new Error('Error getting workflows from PagerDuty. ' + responseBody);
    }

    return response.items;
  },

  /**
   * Trigger an incident workflow in PagerDuty for a specific incident.
   * @param {String} requester a "from" field sent to PagerDuty in a header, should contain an email
   * @param {String} triggerId the Id of the trigger we want to run
   * @param {String} incidentId the id of the corresponding incident
   * @param {String} snIncidentId snow incident id
   * @param {String} incidentWorkflowName name of the incident workflow
   * @return {Object} API call response body
   */
  triggerIncidentWorkflow: function (requester, triggerId, incidentId, snIncidentId, incidentWorkflowName) {
    var feature = 'incident_workflows/triggers/' + triggerId + '/start';

    var body = {
      incident_id: incidentId,
      source_name: this.serviceNow
    };

    var response = this.rest.postREST(feature, body, requester);

    var responseBody = response.haveError() ? this.extractPDIncidentError(response) : response.getBody();
    var status = response.getStatusCode();
    gs.debug('trigger workflow response: {0}:{1}', status, responseBody);

    if (status !== 200) {
      gs.warn('POST Incident workflow trigger failed. Status: ' + status + '; Message: ' +
        responseBody + '; Query: ' + feature);
      throw new Error(responseBody);
    }

    var note = 'Incident Workflow "' + incidentWorkflowName + '" has been run by ' + gs.getUserDisplayName();

    var notesHelper = x_pd_integration.WorkNotesHelper;
    if (notesHelper.isEnabled('show_notes_on_incident_workflow')) {
      var target = new GlideRecordSecure('incident');
      target.addQuery('sys_id', snIncidentId);
      target.query();
      if (target.next()) {
        target.work_notes = notesHelper.build(note);
        target.update();
      }
    }

    if (this.webhooksV2Identified) {
      // System is all in v3 webhooks, skip inserting on the incident workflow log table
      this.recordWorkflowStart(responseBody, snIncidentId, incidentId);
    }

    return this.JSON.decode(response.getBody());
  },

  /**
   * Fetches the outcome of running a workflow(s) from PagerDuty.
   * Designed for periodic runs.
   * Can throw errors. Please catch them.
   * @return (void)
   */
  fetchWorkflowResults: function () {
    if (!this.isWorkflowEnabled()) {
      return;
    }
    var snLogEntries = this.getLocalEntries();
    snLogEntries.forEach(function (snLogEntry) {
      var pdLogEntries = this.fetchRemoteEntries(snLogEntry.pd_incident_id, snLogEntry.started_at);
      pdLogEntries = this.extractRemoteEntries(pdLogEntries);
      pdLogEntries = this.filterRemoteEntries(pdLogEntries, snLogEntry.started_at, snLogEntry.workflow_name);
      if (pdLogEntries.length === 0) {
        return;
      }
      var pdLogEntry = pdLogEntries[pdLogEntries.length - 1];
      var status = this.getWorkflowStatus(pdLogEntry.summary);

      var grPdWh = new GlideRecordSecure('x_pd_integration_pagerduty_webhooks');
      grPdWh.addQuery('pd_service_id', pdLogEntries[0].serviceId);
      grPdWh.addQuery('webhook_version', 3);
      grPdWh.query();
      if (grPdWh.next()) {
        gs.debug('Incident is already on v3 webhook, do not add incident workflow note.');
        // Mark the record as complete, skip the work note since It was added via webhook v3 payload
        this.recordWorkflowEnd(snLogEntry.sys_id, pdLogEntry.log_entry_id, status);
        return;
      }
      this.addWorkNote(snLogEntry.pd_incident_id, pdLogEntry.summary);
      this.recordWorkflowEnd(snLogEntry.sys_id, pdLogEntry.log_entry_id, status);
    }, this);
  },

  /* --- implementation --- */

  /**
   * Extract the incident error message from PagerDuty
   * @param {String} response from API call
   * @return (String) error message
   */
  extractPDIncidentError: function (response) {
    var errMsg;
    var responseBody = this.JSON.decode(response.getBody());
    if (responseBody.hasOwnProperty('message')) {
      errMsg = responseBody.message;
    } else {
      errMsg = response.getBody();
    }
    if (!errMsg) {
      errMsg = response.getErrorMessage();
    }
    return errMsg;
  },

  /**
   * Record the time the workflow has been launched from ServiceNow UI.
   * @param {String} responseBody from triggerIncidentWorkflow API call
   * @param {String} snIncidentId the sys_id of a ServiceNow incident where a UI modal is shown.
   * It's taken via `g_form.getUniqueValue()` in a "Run a Workflow" UI Action.
   * @param {String} pdIncidentId the PagerDuty incident id taken from the ServiceNow incident record above.
   * @return (void)
   */
  recordWorkflowStart: function (responseBody, snIncidentId, pdIncidentId) {
    var responseObj = JSON.parse(responseBody);
    var grs = new GlideRecordSecure(this.snLogEntriesTable);
    grs.initialize();
    grs.active = 'true';
    grs.incident = snIncidentId;
    grs.pd_incident_id = pdIncidentId;
    grs.started_at = responseObj.workflow_instance.started_at;
    grs.status = responseObj.workflow_instance.status;
    grs.workflow_name = responseObj.workflow_instance.workflow.name;
    grs.insert();
  },

  /**
   * Record the time when the workflow has been finished running in PagerDuty.
   * @param {String} sysId the sys id of the ServiceNow log entry in the `this.snLogEntriesTable`
   * @param {String} logEntryId the PagerDuty log entry id like `RRGX2H8629BS3V2S9C79PFLTSZ`
   * @param {String} status the status of the workflow run based _only_ on its summary
   * @return (void)
   */
  recordWorkflowEnd: function (sysId, logEntryId, status) {
    var grs = new GlideRecordSecure(this.snLogEntriesTable);
    grs.addQuery('sys_id', sysId);
    grs.query();
    if (grs.next()) {
      grs.active = 'false';
      grs.log_entry_id = logEntryId;
      grs.status = status;
      grs.update();
    }
  },

  /**
   * Get log entries from local db. You can treat these as Workflow "launches".
   * @return {Array} a list of log entries stored locally regardless of an incident
   */
  getLocalEntries: function () {
    var localEntries = [];
    var grs = new GlideRecordSecure(this.snLogEntriesTable);
    grs.addActiveQuery();
    grs.orderBy('started_at');
    grs.query();
    while (grs.next()) {
      localEntries.push({
        pd_incident_id: grs.pd_incident_id + '',
        started_at: grs.started_at + '',
        sys_id: grs.sys_id + '',
        workflow_name: grs.workflow_name + ''
      });
    }
    return localEntries;
  },

  /**
   * Fetch log entries from PagerDuty corresponding to the ones stored in ServiceNow
   * @param {String} pdIncidentId the PagerDuty incident id for which the log entries are fetched
   * @param {String} since the datetime in UTC to filter the log entries
   * @return {Array} a list of log entries for a given PagerDuty incident
   */
  fetchRemoteEntries: function (pdIncidentId, since) {
    if (this.logEntriesCache[pdIncidentId]) {
      return this.logEntriesCache[pdIncidentId];
    }
    var feature = 'incidents/' + pdIncidentId + '/log_entries?since=' + since;
    var response = this.rest.getREST(feature, {});
    if (this.rest.hasError()) {
      throw new Error(this.rest.getError());
    }
    var responseBody = response.haveError() ? this.extractPDIncidentError(response) : response.getBody();
    var status = response.getStatusCode();
    if (status !== 200) {
      gs.warn('GET incident log entries failed for an incident ' + pdIncidentId +
        '; Status: ' + status + '; Message: ' + responseBody + '; Query: ' + feature);
      throw new Error(responseBody);
    }
    var body = JSON.parse(responseBody);
    this.logEntriesCache[pdIncidentId] = body.log_entries;
    return body.log_entries;
  },

  /**
   * Extract workflows entries from all log entries
   * @param {Array} logEntries all log entries for a given incident
   * @return {Array} a filtered list of only workflow log entries
   */
  extractRemoteEntries: function (logEntries) {
    var localLogEntries = {};
    var grs = new GlideRecordSecure(this.snLogEntriesTable);
    grs.addNotNullQuery('log_entry_id');
    grs.query();
    while (grs.next()) {
      localLogEntries[grs.log_entry_id + ''] = true;
    }

    var remoteEntries = [];
    logEntries.forEach(function (logEntry) {
      if (logEntry.type === 'workflow_log_entry_log_entry' &amp;&amp; !localLogEntries[logEntry.id]) {
        remoteEntries.push({
          log_entry_id: logEntry.id,
          message: logEntry.message,
          started_at: logEntry.created_at,
          summary: logEntry.summary,
          serviceId: logEntry.service.id
        });
      }
    });
    return remoteEntries;
  },

  filterRemoteEntries: function (pdLogEntries, startedAt, workflowName) {
    return pdLogEntries
      .filter(function (pdLogEntry) {
        return pdLogEntry.started_at &gt;= startedAt;
      })
      .filter(function (pdLogEntry) {
        var namePosition = pdLogEntry.summary.lastIndexOf(workflowName);
        var completedPosition = pdLogEntry.summary.lastIndexOf('completed');
        return namePosition &gt; -1 &amp;&amp;
          completedPosition &gt; -1 &amp;&amp;
          completedPosition &gt; namePosition;
      });
  },

  addWorkNote: function (incidentId, workNote) {
    var notesHelper = x_pd_integration.WorkNotesHelper;
    if (!notesHelper.isEnabled('show_notes_on_incident_workflow')) {
      return;
    }
    var grs = new GlideRecordSecure('incident');
    grs.addQuery('x_pd_integration_incident', incidentId);
    grs.query();
    if (grs.next()) {
      grs.work_notes = notesHelper.build(workNote);
      grs.update();
    }
  },

  getWorkflowStatus: function (summary) {
    var status = 'running';
    // eslint-disable-next-line es5/no-es6-methods
    if (summary.includes('completed with an error')) {
      status = 'failed';
    // eslint-disable-next-line es5/no-es6-methods
    } else if (summary.includes('completed.')) {
      status = 'completed';
    }
    return status;
  },

  type: 'IncidentWorkflows'
};
</script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>PagerDuty_v8.0</sys_created_by>
        <sys_created_on>2023-01-13 15:50:24</sys_created_on>
        <sys_id>28acb0761b942110f81c877ddc4bcbd3</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>IncidentWorkflows</sys_name>
        <sys_package display_value="PagerDuty Incident Resolution Platform" source="x_pd_integration">39a9d9664f834e00dd657bb28110c77b</sys_package>
        <sys_policy/>
        <sys_scope display_value="PagerDuty Incident Resolution Platform">39a9d9664f834e00dd657bb28110c77b</sys_scope>
        <sys_update_name>sys_script_include_28acb0761b942110f81c877ddc4bcbd3</sys_update_name>
        <sys_updated_by>PagerDuty_v8.0</sys_updated_by>
        <sys_updated_on>2023-01-13 15:50:24</sys_updated_on>
    </sys_script_include>
</record_update>
