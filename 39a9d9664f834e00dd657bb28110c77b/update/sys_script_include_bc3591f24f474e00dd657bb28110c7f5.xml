<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_pd_integration.PagerDuty_REST</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>/*** Changes made to this script are not supported by PagerDuty ***/&#13;
Handles outbound communication to PagerDuty. Supports both Integration API and REST API.</description>
        <name>PagerDuty_REST</name>
        <script>/*** Changes made to this script are not supported by PagerDuty ***/
/*
 * PagerDuty API REST methods
 */

var PagerDuty_REST = Class.create();

PagerDuty_REST.prototype = {
  initialize: function (baseRestEndpoint) {
    this.JSON = new global.JSON();

    // API properties
    this.authToken = gs.getProperty('x_pd_integration.api_key');
    this.baseRestEndpoint = baseRestEndpoint || gs.getProperty('x_pd_integration.rest_api_endpoint');

    this.customHeaders = gs.getProperty('x_pd_integration.http_headers');
    this.useMidServer = gs.getProperty('x_pd_integration.enable_mid_server');
    this.midServer = gs.getProperty('x_pd_integration.mid_server');
    this.eccParams = gs.getProperty('x_pd_integration.ecc_params');

    this.clientUrl = gs.getProperty('glide.servlet.uri');
    this.clientName = 'ServiceNow';
    this.clientHeader = 'X-PagerDuty-Client';

    // for local dev only - allows to debug all http requests.
    this.debugHTTPRequests = false;

    this._errorMsg = '';
    this._hasError = false;
  },

  /**
   * Get the ServiceNow version in use
   */
  getClientVersion: function () {
    var scope = 'x_pd_integration';

    // GlideRecordSecure is changed to GlideRecord below, because GlideRecordSecure
    // leads to an error message [There is no app with the scope x_pd_integration]
    // in logs despite being executed without errors in [Scripts - Background]
    var grApp = new GlideRecord('sys_scope');

    grApp.addQuery('scope', scope);
    grApp.query();
    if (!grApp.next()) {
      gs.error('There is no app with the scope {0}', scope);
      return '';
    }
    return grApp.getValue('version');
  },

  /**
   * @param {String} httpMethod - HTTP Method ('get, 'put', 'post', 'patch', 'delete')
   * @param {String} requester - e-mail to be set in the 'From' header
   * @param {String} clientUrl - client URL (overrides value from glide.servlet.uri system property)
   * @returns {RESTMessageV2} Rest message object
   */
  createBaseRestMessage: function (httpMethod, requester, clientUrl) {
    var restMessage = new sn_ws.RESTMessageV2();
    if (this.debugHTTPRequests) {
      restMessage.setLogLevel('all');
    }
    restMessage.setHttpMethod(httpMethod);
    this.setBaseHeaders(restMessage);

    // MID server configuration (server, ECC params, HTTP headers)
    this.configureMIDServer(restMessage);

    // Custom HTTP headers regardless of MID server settings
    this.setCustomHeaders(restMessage);

    if (!gs.nil(requester)) {
      restMessage.setRequestHeader('From', requester);
    }
    var url = gs.nil(clientUrl) ? this.clientUrl : clientUrl;
    restMessage.setRequestHeader(this.clientHeader, this.getClientHeader(this.clientName, url));
    return restMessage;
  },
  /**
   * Put message body to specific feature
   * @param {String} endpoint feature
   * @param {Object} request body
   * @param (String) client URL (to override the default client URL)
   * @return {Object} parsed JSON
   */
  putREST: function (feature, body, requester, clientUrl) {
    var response = null;
    try {
      var restMessage = this.createBaseRestMessage('put', requester, clientUrl);
      var bodyJSON = this.JSON.encode(body);

      restMessage.setEndpoint(this.baseRestEndpoint + '/' + feature);
      restMessage.setRequestBody(bodyJSON);

      // Execute
      response = this.executeWithTooManyRequestsHandling(restMessage);

    } catch (ex) {
      this._setError('putREST', ex);
      gs.error('putREST error: {0}', ex);
    } finally {
      return response;
    }

  },

  /**
   * Sends POST request
   * @param {String} feature - endpoint for the REST message
   * @param {Object} body - request body content
   * @param {String} requester - e-mail to be set in the 'From' header
   * @param {String} clientUrl - client URL (overrides value from glide.servlet.uri system property)
   * @returns {RESTResponseV2}
   */
  postREST: function (feature, body, requester, clientUrl) {
    var response = null;
    try {
      var restMessage = this.createBaseRestMessage('post', requester, clientUrl);
      restMessage.setEndpoint(this.baseRestEndpoint + '/' + feature);

      if (!gs.nil(body)) {
        var bodyJSON = this.JSON.encode(body);
        restMessage.setRequestBody(bodyJSON);
      }

      response = this.executeWithTooManyRequestsHandling(restMessage);

    } catch (ex) {
      this._setError('postREST', ex);
      gs.error('postREST error: {0}', ex);
    } finally {
      return response;
    }
  },
  wait: function (ms) {
    var start = new Date().getTime();
    while (new Date().getTime() &lt; start + ms) {
      // do nothing
    }
  },
  executeWithTooManyRequestsHandling: function (restMessage, attempts) {
    attempts = attempts || 1;
    var response = restMessage.execute();
    if (response.getStatusCode() === 429) {
      if (attempts &lt;= 3) {
        gs.info('Received 429 - Too many requests. Retrying.');
        this.wait(15000 * attempts);
        return this.executeWithTooManyRequestsHandling(restMessage, ++attempts);
      }
      gs.info('Received 429 - Too many requests. Giving up after 3 attempts');
    }
    return response;
  },
  /**
   * Sends GET request
   * @param {String} endpoint feature
   * @param {Object} message parameters
   * @return {RESTResponse} post response
   */
  getREST: function (feature, params, requester) {
    var response = null;
    try {
      var restMessage = this.createBaseRestMessage('get', requester, null);
      restMessage.setEndpoint(this.baseRestEndpoint + '/' + feature);

      for (var parm in params) {
        restMessage.setQueryParameter(parm, params[parm]);
      }

      // Execute
      response = this.executeWithTooManyRequestsHandling(restMessage);

    } catch (ex) {
      this._setError('getREST', ex);
      gs.error('getREST error: {0}', ex);
    } finally {
      return response;
    }
  },


  /**
   * Sends DELETE request
   * @param {String} endpoint feature
   * @return {RESTResponse} post response
   */
  deleteREST: function (feature) {
    var response = null;
    try {
      var restMessage = this.createBaseRestMessage('delete', null, null);
      restMessage.setEndpoint(this.baseRestEndpoint + '/' + feature);

      // Execute
      response = this.executeWithTooManyRequestsHandling(restMessage);

    } catch (ex) {
      this._setError('deleteREST', ex);
      gs.error('deleteREST error: {0}', ex);
    } finally {
      return response;
    }
  },

  /**
   * Patch message body to specific feature
   * @param {String} endpoint feature
   * @param {String} request body
   * @return {RESTResponse} patch response
   */
  patchREST: function (feature, body) {
    var response = null;
    try {
      var restMessage = this.createBaseRestMessage('patch', null, null);
      var bodyJSON = this.JSON.encode(body);

      restMessage.setEndpoint(this.baseRestEndpoint + '/' + feature);
      restMessage.setRequestBody(bodyJSON);

      // Execute
      response = this.executeWithTooManyRequestsHandling(restMessage);

    } catch (ex) {
      this._setError('patchREST', ex);
      gs.error('patchREST error: {0}', ex);
    } finally {
      return response;
    }
  },

  setBaseHeaders: function (restMessage) {
    restMessage.setRequestHeader('Accept', 'application/vnd.pagerduty+json;version=2');
    restMessage.setRequestHeader('Authorization', 'Token token=' + this.authToken);
    restMessage.setRequestHeader('Content-Type', 'application/json');
  },

  setCustomHeaders: function (restMessage) {
    if (gs.nil(this.customHeaders)) {
      return;
    }
    var headers = this.customHeaders.split('\n').filter(Boolean).map(function (header) {
      return header.split(':');
    }).map(function (pair) {
      return pair.map(function (e) {
        return e.trim();
      });
    });
    headers.forEach(function (header) {
      restMessage.setRequestHeader(header[0], header[1]);
    });
  },

  configureMIDServer: function (restMessage) {
    if (this.useMidServer !== 'true') {
      return;
    }
    restMessage = new PagerDutyCustomMIDServerConfiguration().setCustomHeaders(restMessage);
    restMessage.setMIDServer(this.midServer);
    restMessage.setEccParameter('skip_sensor', 'true');

    if (!gs.nil(this.eccParams)) {
      var eccParams = this.eccParams.split('\n').filter(Boolean).map(function (eccParam) {
        return eccParam.split(':');
      }).map(function (pair) {
        return pair.map(function (e) {
          return e.trim();
        });
      });
      eccParams.forEach(function (eccParam) {
        restMessage.setEccParameter(eccParam[0], eccParam[1]);
      });
    }
  },

  /**
   * Remove the webhook.config.snow_password field on the debug message
   * @return {String} encoded body string
   */
  _removePassword: function (body) {
    if (body.hasOwnProperty('webhook')) {
      var webhook = body.webhook;
      if (webhook.hasOwnProperty('config')) {
        var config = webhook.config;
        if (config.hasOwnProperty('snow_password')) {
          delete body.webhook.config.snow_password;
        }
      }
    }
    if (body.hasOwnProperty('authenticationSecrets')) {
      delete body.authenticationSecrets;
    }
    return this.JSON.encode(body);
  },

  /**
   * Track error
   * @param {String} method reporting error
   * @param {String} error message
   * @return void
   */
  _setError: function (method, msg) {
    this._errorMsg = method + ' error: ' + msg;
    this._hasError = true;
  },

  /**
   * Does class have an error
   * @return {Boolean} has error
   */
  hasError: function () {
    return this._hasError;
  },


  /**
   * Get last error message
   * @return {String} error message
   */
  getError: function () {
    if (!gs.nil(this._errorMsg)) {
      return this._errorMsg;
    }
  },

  /**
   * Sends GET request. Throws exception in case of error
   * @param {String} endpoint - PagerDuty endpoint
   * @returns {Object} Response status code and data (JSON response parsed)
   * @throws {Error} in case of error
   */
  getRESTThrowable: function (endpoint) {
    var response = this.getREST(endpoint);
    if (this.hasError()) {
      throw new Error(this.getError());
    }
    if (response.haveError()) {
      throw new Error(this.extractPagerDutyErrorResponse(response));
    }
    return {
      status: response.getStatusCode(),
      data: JSON.parse(response.getBody())
    };
  },

  /**
   * Get all the items using pagination
   * @param {String} pathString path to a feature, e.g. 'extensions', w/ or w/o query params
   * @param {Function} transformItem function with one param (item), should return item modified
   * @return {List} items taken from the endpoint
   */
  getAllItems: function (pathString, transformItem) {
    var items = [];
    var path = pathString.split('?')[0];
    var junction = pathString === path ? '?' : '&amp;';
    var maxPages = 500; // so, max 500.000 items can be retrieved
    try {
      var transformItems = function (responseBody) {
        if (!responseBody || !(responseBody[path] instanceof Array)) {
          return [];
        }
        return responseBody[path].map(function (item) {
          return transformItem instanceof Function ? transformItem(item) : item;
        });
      };
      var responseBody = this.getRESTThrowable(pathString + junction + 'limit=100').data;
      items = items.concat(transformItems(responseBody));
      var safetyCounter = 1;
      while (responseBody &amp;&amp; responseBody.more) {
        if (safetyCounter &gt; maxPages) {
          break;
        }
        safetyCounter++;
        var offset = responseBody.offset + responseBody.limit;
        responseBody = this.getRESTThrowable(pathString + junction + 'limit=' + responseBody.limit + '&amp;offset=' + offset).data;
        items = items.concat(transformItems(responseBody));
      }
    } catch (e) {
      this._setError('getAllItems', e.message);
    }
    return items;
  },
  getAllItemsThrowable: function (pathString, transformItem) {
    var result = this.getAllItems(pathString, transformItem);
    if (this.hasError()) {
      throw new Error(this.getError());
    }
    return result;
  },

  /**
   * Get all items from an endpoint using cursor pagination
   * @param {String} pathString path to a feature
   * @param {Object} params - message parameters
   * @param {String} requester "from" field, should contain an email
   * @param {Function} transformItem function with one param (item), should return item modified
   * @return {List} all items taken from the endpoint
   */
  getAllItemsByCursor: function (pathString, params, requester, transformItem) {
    var items = [];
    var path = pathString.split('?')[0];
    var junction = pathString === path ? '?' : '&amp;';

    try {
      var response = this.getREST(pathString, params, requester);
      var responseBody = JSON.parse(response.getBody());
      items = items.concat(transformItem(responseBody));
      while (responseBody &amp;&amp; responseBody.more) {
        var cursor = responseBody.next_cursor;
        response = this.getREST(pathString + junction + 'cursor=' + cursor, params, requester);
        responseBody = JSON.parse(response.getBody());
        items = items.concat(transformItem(responseBody));
      }

      return {items: items, status: response.getStatusCode(), body: response};
    } catch (error) {
      return {items: items, status: 500, error: 'Unexpected error'};
    }
  },

  /**
   * Get the 'X-PagerDuty-Client' header in the correct format
   * @param {String} clientName client name
   * @param {String} clientUrl client url
   * @return {String} the header
   */
  getClientHeader: function (clientName, clientUrl) {
    return '"' + clientName + ' (PD v' + this.getClientVersion() + ')" &lt;' + clientUrl + '&gt;';
  },

  getDefaultClientHeader: function () {
    return this.getClientHeader(this.clientName, this.clientUrl);
  },

  /**
   * Sends POST request. Throws exception in case of error
   * @param {String} endpoint - PagerDuty endpoint
   * @param {Object} body - request body content
   * @param {String} requester - e-mail to be set in the 'From' header
   * @returns {Object} Response status code and data (JSON response parsed)
   * @throws {Error} in case of error
   */
  postRESTThrowable: function (endpoint, body, requester) {
    var response = this.postREST(endpoint, body, requester);

    if (this.hasError()) {
      throw new Error(this.getError());
    }

    if (response.haveError()) {
      throw new Error(this.extractPagerDutyErrorResponse(response));
    }
    return {
      status: response.getStatusCode(),
      data: JSON.parse(response.getBody())
    };
  },

  /**
  * Put to PagerDuty and throw exception in case of error
  * @param {String} endpoint of PagerDuty
  * @param {Object} body of the request
  * @param {String} requester is the value of the [From] request header
  * @returns {Object} Response status code and data (JSON response parsed)
  */
  putRESTThrowable: function (endpoint, body, requester) {
    var response = this.putREST(endpoint, body, requester);

    if (this.hasError()) {
      throw new Error(this.getError());
    }

    if (response.haveError()) {
      throw new Error(this.extractPagerDutyErrorResponse(response));
    }
    return {
      status: response.getStatusCode(),
      data: JSON.parse(response.getBody())
    };
  },

  /**
  * DELETE to PagerDuty and throw exception in case of error
  * @param {String} endpoint of PagerDuty
  * @param {Object} body of the request
  * @param {String} requester is the value of the [From] request header
  * @returns {Object} Response status code and data (JSON response parsed)
  */
  deleteRESTThrowable: function (endpoint, body, requester) {
    var response = this.deleteREST(endpoint, body, requester);

    if (this.hasError()) {
      throw new Error(this.getError());
    }

    if (response.haveError()) {
      throw new Error(this.extractPagerDutyErrorResponse(response));
    }
    return {
      status: response.getStatusCode(),
      data: JSON.parse(response.getBody())
    };
  },
  /**
 * Extract the incident error message from PagerDuty
 * @param {String} response from API call
 * @return (String) error message
 */
  extractPagerDutyErrorResponse: function (response) {
    var errMsg = response.getErrorMessage();
    if (!response.getBody()) {
      return errMsg;
    }
    var responseBody = global.JSON.parse(response.getBody());
    if (responseBody.hasOwnProperty('error')) {
      var error = responseBody.error;
      if (error.hasOwnProperty('errors')) {
        var errors = error.errors;
        if (errors.length &gt; 0) {
          errMsg = errors[0];
        }
      } else if (error.hasOwnProperty('message')) {
        errMsg = error.message;
      }
    }
    return errMsg;
  },
  type: 'PagerDuty_REST'
};

if (gs.getProperty('x_pd_integration.testing_mode_enabled') === 'true') {
  try {
    x_pd_integration.SimpleObjStubUtil.stub(PagerDuty_REST.prototype, x_pd_integration.OutboundRequestsStubConfig);
  } catch (e) {
    gs.error(e);
  }
}
</script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>PagerDuty_v8.0</sys_created_by>
        <sys_created_on>2015-10-15 15:54:06</sys_created_on>
        <sys_id>bc3591f24f474e00dd657bb28110c7f5</sys_id>
        <sys_mod_count>142</sys_mod_count>
        <sys_name>PagerDuty_REST</sys_name>
        <sys_package display_value="PagerDuty Incident Resolution Platform" source="x_pd_integration">39a9d9664f834e00dd657bb28110c77b</sys_package>
        <sys_policy/>
        <sys_scope display_value="PagerDuty Incident Resolution Platform">39a9d9664f834e00dd657bb28110c77b</sys_scope>
        <sys_update_name>sys_script_include_bc3591f24f474e00dd657bb28110c7f5</sys_update_name>
        <sys_updated_by>PagerDuty_v8.0</sys_updated_by>
        <sys_updated_on>2020-08-17 08:28:58</sys_updated_on>
    </sys_script_include>
</record_update>
